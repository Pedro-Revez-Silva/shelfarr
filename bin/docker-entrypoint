#!/bin/bash -e

# Control whether to attempt ownership changes on startup.
CHOWN_ON_START="${CHOWN_ON_START:-auto}"

if [ -n "${SKIP_CHOWN:-}" ]; then
  CHOWN_ON_START="never"
fi

case "$CHOWN_ON_START" in
  auto|always|never) ;;
  *) 
    echo "Unknown CHOWN_ON_START value '${CHOWN_ON_START}', defaulting to 'auto'."
    CHOWN_ON_START="auto"
    ;;
esac

run_as_rails() {
  if [ "$(id -u)" = "0" ]; then
    gosu rails "$@"
  else
    "$@"
  fi
}

verify_path_writable() {
  local path="$1"
  local marker="${path%/}/.shelfarr-startup-check.$$"

  if run_as_rails sh -c "touch \"${marker}\" && rm -f \"${marker}\""; then
    return 0
  fi

  return 1
}

ensure_storage_path_permissions() {
  local path="$1"
  local action="$2"
  local policy="${action:-$CHOWN_ON_START}"

  mkdir -p "$path"

  if [ "$(id -u)" = "0" ] && [ "$policy" != "never" ]; then
    if ! chown -R rails:rails "$path" 2>/tmp/shelfarr-chown-error.$$; then
      if [ "$policy" = "always" ]; then
        echo "Failed to chown $path and CHOWN_ON_START=always is set."
        cat /tmp/shelfarr-chown-error.$$
        rm -f /tmp/shelfarr-chown-error.$$
        exit 1
      fi

      echo "Warning: unable to chown ${path}; continuing for read/write-capable filesystems."
      echo "If filesystem permissions are not writable by UID ${PUID}/${PGID}, set CHOWN_ON_START=always or CHOWN_ON_START=never accordingly."
      rm -f /tmp/shelfarr-chown-error.$$
    fi
  fi

  if ! verify_path_writable "$path"; then
    echo "Storage path ${path} is not writable by the rails user. Check permissions for UID ${PUID} and GID ${PGID}."
    exit 1
  fi
}

# =============================================================================
# PUID/PGID Support
# =============================================================================
# Allows users to specify the UID/GID the container should run as.
# This resolves permission issues when mounting host volumes.
# Defaults to 1000:1000 for backward compatibility.

PUID=${PUID:-1000}
PGID=${PGID:-1000}

# Only modify user/group if running as root
if [ "$(id -u)" = "0" ]; then
  # Modify rails group GID if different from default
  if [ "$(id -g rails)" != "$PGID" ]; then
    groupmod -o -g "$PGID" rails
    echo "Set rails group GID to $PGID"
  fi

  # Modify rails user UID if different from default
  if [ "$(id -u rails)" != "$PUID" ]; then
    usermod -o -u "$PUID" rails
    echo "Set rails user UID to $PUID"
  fi
fi

# Ensure storage directory is usable by the rails user
ensure_storage_path_permissions "/rails/storage"

# =============================================================================
# Secret Key Generation
# =============================================================================
# Auto-generate SECRET_KEY_BASE if not provided
# This allows "just run docker-compose up" without manual key generation

if [ -z "$RAILS_MASTER_KEY" ] && [ -z "$SECRET_KEY_BASE" ]; then
  SECRET_FILE="/rails/storage/.secret_key_base"

  if [ -f "$SECRET_FILE" ]; then
    # Reuse existing auto-generated key
    export SECRET_KEY_BASE=$(cat "$SECRET_FILE")
    echo "Using existing auto-generated secret key"
  else
    # Generate new key and persist it
    export SECRET_KEY_BASE=$(openssl rand -hex 64)
    echo "$SECRET_KEY_BASE" > "$SECRET_FILE"
    chmod 600 "$SECRET_FILE"
    echo "Generated new secret key (saved to storage volume)"
  fi
fi

# =============================================================================
# Encryption Keys Generation
# =============================================================================
# Auto-generate ActiveRecord encryption keys if not provided
# These are required for encrypted attributes (e.g., API keys in settings)

ENCRYPTION_FILE="/rails/storage/.encryption_keys"

if [ -z "$ACTIVE_RECORD_ENCRYPTION_PRIMARY_KEY" ]; then
  if [ -f "$ENCRYPTION_FILE" ]; then
    # Reuse existing encryption keys
    source "$ENCRYPTION_FILE"
    echo "Using existing auto-generated encryption keys"
  else
    # Generate new encryption keys and persist them
    export ACTIVE_RECORD_ENCRYPTION_PRIMARY_KEY=$(openssl rand -base64 32)
    export ACTIVE_RECORD_ENCRYPTION_DETERMINISTIC_KEY=$(openssl rand -base64 32)
    export ACTIVE_RECORD_ENCRYPTION_KEY_DERIVATION_SALT=$(openssl rand -base64 32)

    cat > "$ENCRYPTION_FILE" <<EOF
export ACTIVE_RECORD_ENCRYPTION_PRIMARY_KEY="$ACTIVE_RECORD_ENCRYPTION_PRIMARY_KEY"
export ACTIVE_RECORD_ENCRYPTION_DETERMINISTIC_KEY="$ACTIVE_RECORD_ENCRYPTION_DETERMINISTIC_KEY"
export ACTIVE_RECORD_ENCRYPTION_KEY_DERIVATION_SALT="$ACTIVE_RECORD_ENCRYPTION_KEY_DERIVATION_SALT"
EOF
    chmod 600 "$ENCRYPTION_FILE"
    echo "Generated new encryption keys (saved to storage volume)"
  fi
fi

# =============================================================================
# Database Setup
# =============================================================================
# If running the rails server then create or migrate existing database

if [ "${@: -2:1}" == "./bin/rails" ] && [ "${@: -1:1}" == "server" ]; then
  # Run database setup as rails user if we're root
  if [ "$(id -u)" = "0" ]; then
    gosu rails ./bin/rails db:prepare
    gosu rails ./bin/rails runner 'SettingsService.seed_defaults!'
  else
    ./bin/rails db:prepare
    ./bin/rails runner 'SettingsService.seed_defaults!'
  fi
fi

# Re-check permissions after files are created during startup.
ensure_storage_path_permissions "/rails/storage"
ensure_storage_path_permissions "/rails/tmp"

# =============================================================================
# Start Application
# =============================================================================
# Drop privileges if running as root, then execute the command

if [ "$(id -u)" = "0" ]; then
  exec gosu rails "$@"
else
  exec "$@"
fi
